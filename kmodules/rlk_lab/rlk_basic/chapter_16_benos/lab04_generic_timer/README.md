# 实验16-4：中断实验
## 1．实验目的
1)	通过本实验了解和熟悉ARM64汇编。
2)	了解和熟悉ARM64的异常等级处理。
3)	了解和熟悉ARM64的中断处理流程。
4)	了解和熟悉树莓派的系统定时器（System Timer）的使用。
## 2．实验要求
1. 在启动汇编中实现对ARM64异常向量表的支持。
2. 利用树莓派中的系统定时器来作为中断源，编写一个中断处理程序。每当有定时器中断到来时打印输出“Timer interrupt occured”。
## 3．实验提示
### （1）关于异常向量
当一个中断发生时，CPU核心感知到异常发生，硬件会自动做如下一些事情 。
* 处理器的状态保存在对应的异常等级的SPSR_ELx寄存器中。
* 返回地址保存在对应的异常等级的ELR_ELx寄存器中。
* PSTATE寄存器里的DAIF域都设置为1，相当于把调试异常、系统错误（SError）、IRQ中断以及FIQ中断都关闭了。PSTATE寄存器是ARM v8里新增的寄存器。
* 如果是同步异常，那么究竟什么原因导致的呢？具体原因要看ESR_ELx寄存器。
* 设置栈指针，指向对应异常等级里的栈。
* 迁移处理器等级到对应的异常等级，然后跳转到异常向量表里执行。
上述是ARM处理器检测到IRQ中断后自动做的事情，软件需要做的事情从中断向量表开始。

读者可以参考第3.5.4节关于ARM64异常向量表中的介绍。

另外，读者可以参考Linux内核中关于异常向量表处理的汇编代码，比如linux内核中的arch/arm64/kernel/entry.S文件。
当异常发生时，CPU会根据异常向量表跳转到对应表项中。在异常向量表中存放了相应异常处理的跳转函数。例如，对于IRQ中断，通常有两种场景：
1.	IRQ中断发生在内核态，也就是CPU正在EL1异常等级下执行时发生了外设中断。
2.	IRQ中断发生在用户态，也就是CPU正在EL0异常等级下执行时发生了外设中断。
我们以第一种情况，当IRQ中断发生在内核态时，CPU会根据异常向量表跳转到对应表项中，跳转到el1_irq函数（以Linux内核为例）中。在el1_irq函数里会保存相应的中断上下文，然后再跳转到具体中断的处理函数中。因此，本实验的难点就是异常向量表的处理以及如何保存中断上下文。

### （2）系统定时器
树莓派中的BCM2837芯片中提供了一个系统定时器，它提供4个32位的定时器通道以及一个64位的计数器。每个定时器通道提供一个输出比较寄存器（Output Compare Register），用来和计数器进行比较。当计数器到达输出比较寄存器的阈值时会触发一个定时器中断，这时软件在中断服务例程中重新设置一个新的值到输出比较寄存器。读者可以参考BCM2837芯片手册的第12章相关内容。

### （3）BCM2837中断控制器
BCM2837芯片支持的中断源主要来自ARM处理器和GPU处理器。对于ARM处理器来说可以读取三种类型的中断。
* 来自ARM侧的外设中断。
* 来自GPU侧的外设中断。
* 特殊的事件中断。

由于支持的外设中断不多，BCM2837芯片并没有采用复杂和流行的GIC中断控制器，而是采用简单的查询寄存器（pending register）的方式。BCM2837芯片提供中断等待寄存器（IRQ Pending Register）、中断使能寄存器（IRQ Enable Register）以及关闭中断寄存器（IRQ Disable Register）。读者可以参考BCM2837芯片手册的第7章内容。
